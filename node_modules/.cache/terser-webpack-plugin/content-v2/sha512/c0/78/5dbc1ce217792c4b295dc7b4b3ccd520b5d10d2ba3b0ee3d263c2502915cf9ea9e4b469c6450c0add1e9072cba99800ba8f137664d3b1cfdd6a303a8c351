{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[493],{888:function(v,_,t){\"use strict\";t.r(_);var l=t(55),a=Object(l.a)({},(function(){var v=this,_=v.$createElement,t=v._self._c||_;return t(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":v.$parent.slotKey}},[t(\"h1\",{attrs:{id:\"概览\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#概览\"}},[v._v(\"#\")]),v._v(\" 概览\")]),v._v(\" \"),t(\"p\",[v._v(\"排序或许是前端接触最多的算法了，很多人的算法之路是从一个冒泡排序开始的，排序的方法有非常多中，它们各自有各自的应用场景和优缺点，这里我推荐如下6种应用最多的排序方法，如果你有兴趣也可以研究下其他几种。\")]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"快速排序\")])]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"选择一个目标值，比目标值小的放左边，比目标值大的放右边，目标值的位置已排好，将左右两侧再进行快排。\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"归并排序\")])]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"大序列二分成小序列，将小序列排序后再将排序后的小序列归并成大序列。\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"选择排序\")])]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"每次排序取一个最大或最小的数字放到前面的有序序列中。\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"插入排序\")])]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"将左侧序列看成一个有序序列，每次将一个数字插入该有序序列。插入时，从有序序列最右侧开始比较，若比较的数较大，后移一位。\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"冒泡排序\")])]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"循环数组，比较当前元素和下一个元素，如果当前元素比下一个元素大，向上冒泡。下一次循环继续上面的操作，不循环已经排序好的数。\")])]),v._v(\" \"),t(\"ul\",[t(\"li\",[v._v(\"堆排序\")])]),v._v(\" \"),t(\"blockquote\",[t(\"p\",[v._v(\"创建一个大顶堆，大顶堆的堆顶一定是最大的元素。交换第一个元素和最后一个元素，让剩余的元素继续调整为大顶堆。从后往前以此和第一个元素交换并重新构建，排序完成。\")])]),v._v(\" \"),t(\"h2\",{attrs:{id:\"系统自带排序实现\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#系统自带排序实现\"}},[v._v(\"#\")]),v._v(\" 系统自带排序实现\")]),v._v(\" \"),t(\"p\",[v._v(\"每个语言的排序内部实现都是不同的。\")]),v._v(\" \"),t(\"p\",[v._v(\"对于 JS 来说，数组长度大于 10 会采用快排，否则使用插入排序。选择插入排序是因为虽然时间复杂度很差，但是在数据 量很小的情况下和 O(N * logN) 相差无几，然而插入排序需要的常数时间很小，所以相对别的排序来说更快。\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"稳定性\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#稳定性\"}},[v._v(\"#\")]),v._v(\" 稳定性\")]),v._v(\" \"),t(\"p\",[v._v(\"稳定性的意思就是对于相同值来说，相对顺序不能改变。通俗的讲有两个相同的数 A 和 B，在排序之前 A 在 B 的前面， 而经过排序之后，B 跑到了 A 的前面，对于这种情况的发生，我们管他叫做排序的不稳定性。\")]),v._v(\" \"),t(\"p\",[v._v(\"稳定性有什么意义？个人理解对于前端来说，比如我们熟知框架中的虚拟 DOM 的比较，我们对一个``列表进行渲染， 当数据改变后需要比较变化时，不稳定排序或操作将会使本身不需要变化的东西变化，导致重新渲染，带来性能的损耗。\")]),v._v(\" \"),t(\"h2\",{attrs:{id:\"排序面试题目\"}},[t(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#排序面试题目\"}},[v._v(\"#\")]),v._v(\" 排序面试题目\")]),v._v(\" \"),t(\"ol\",[t(\"li\",[v._v(\"快速排序在完全无序的情况下效果最好，时间复杂度为O(nlogn)，在有序情况下效果最差，时间复杂度为O(n^2)。\")]),v._v(\" \"),t(\"li\",[v._v(\"外部排序常用的算法是归并排序。\")]),v._v(\" \"),t(\"li\",[v._v(\"数组元素基本有序的情况下，插入排序效果最好，因为这样只需要比较大小，不需要移动，时间复杂度趋近于O(n)。\")]),v._v(\" \"),t(\"li\",[v._v(\"如果只想得到1000个元素组成的序列中第5个最小元素之前的部分排序的序列，用堆排序方法最快。\")]),v._v(\" \"),t(\"li\",[v._v(\"对长度为 n 的线性表作快速排序，在最坏情况下，比较次数为 n(n-1)/2。\")])])])}),[],!1,null,null,null);_.default=a.exports}}]);","extractedComments":[]}