{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[738],{1149:function(n,t,i){\"use strict\";i.r(t);var _=i(55),v=Object(_.a)({},(function(){var n=this,t=n.$createElement,i=n._self._c||t;return i(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":n.$parent.slotKey}},[i(\"h1\",{attrs:{id:\"_2\"}},[i(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_2\"}},[n._v(\"#\")]),n._v(\" 2\")]),n._v(\" \"),i(\"p\",[i(\"img\",{attrs:{src:\"https://gitee.com/wddzhahaha/images/raw/master/img/image-20220319222001921.png\",alt:\"image-20220319222001921\"}})]),n._v(\" \"),i(\"blockquote\",[i(\"p\",[n._v(\"this的四种绑定形式\")])]),n._v(\" \"),i(\"p\",[i(\"strong\",[n._v(\"（1.默认绑定 2.隐式绑定 3.显式绑定 4.new绑定）\")]),n._v(\"\\nA. 默认绑定，指向window\\nB. new绑定，指向new创建的对象\\nC. 以为是隐式绑定指向o？用了箭头函数哦，所以还是window\\nD. 默认绑定，指向window\")]),n._v(\" \"),i(\"p\",[n._v(\"不懂this绑定的看下文，或者一句话总结:谁调用this，this指向谁\")]),n._v(\" \"),i(\"ul\",[i(\"li\",[n._v(\"fn()  光秃秃的，默认绑定，指向this，无论在哪里调用都是\\n实际上是window.fn() window调用，指向window\")]),n._v(\" \"),i(\"li\",[n._v(\"obj.fn()   隐式绑定，指向obj，obj在调用\")]),n._v(\" \"),i(\"li\",[n._v(\"call()、apply()、bind 显式绑定，要指向谁就写在()里面\")]),n._v(\" \"),i(\"li\",[n._v(\"new fn()   new绑定，指向new创建的对象\")])]),n._v(\" \"),i(\"p\",[i(\"strong\",[n._v(\"默认绑定\")])]),n._v(\" \"),i(\"p\",[n._v(\"只要是 fn() 这种孤单单的函数执行的 this都是默认绑定，指向window，无论这个fn()在哪里，被嵌套多少层都是指向window\\nA.定时器1秒后 执行函数 function(){...} 就是fn()形式，默认绑定指向window\\n同理D也是\")]),n._v(\" \"),i(\"p\",[n._v(\"主要问题就是C：不细看以为是指向o，但这里用了箭头函数，箭头函数没有自己的this，会去找外层的this当做自己的this，因此还是指向window。\")]),n._v(\" \"),i(\"p\",[i(\"strong\",[n._v(\"new绑定\")])]),n._v(\" \"),i(\"p\",[i(\"strong\",[n._v(\"new一个对象所作的四件事情\")])]),n._v(\" \"),i(\"ol\",[i(\"li\",[n._v(\"新建一个对象\")]),n._v(\" \"),i(\"li\",[n._v(\"把this的指向指向这个对象\")]),n._v(\" \"),i(\"li\",[n._v(\"执行构造函数内的代码\")]),n._v(\" \"),i(\"li\",[n._v(\"返回这个新对象\")])])])}),[],!1,null,null,null);t.default=v.exports}}]);","extractedComments":[]}