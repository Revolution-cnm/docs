{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[913],{1308:function(t,s,e){\"use strict\";e.r(s);var a=e(55),n=Object(a.a)({},(function(){var t=this,s=t.$createElement,e=t._self._c||s;return e(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":t.$parent.slotKey}},[e(\"h1\",{attrs:{id:\"虚拟节点的特点\"}},[e(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#虚拟节点的特点\"}},[t._v(\"#\")]),t._v(\" 虚拟节点的特点\")]),t._v(\" \"),e(\"p\",[t._v(\"Web界面由DOM树(树的意思是数据结构)来构建，当其中一部分发生变化时，其实就是对应某个DOM节点发生了变化，\")]),t._v(\" \"),e(\"p\",[t._v(\"​    虚拟DOM就是为了\"),e(\"strong\",[t._v(\"解决浏览器性能问题\")]),t._v(\"而被设计出来的。\"),e(\"strong\",[t._v(\"如前\")]),t._v(\"，若一次操作中有10次更新DOM的动作，虚拟DOM不会立即操作DOM，而是将这10次更新的diff内容保存到本地一个JS对象中，最终将这个JS对象一次性attch到DOM树上，再进行后续操作，避免大量无谓的计算量。**所以，**用JS对象模拟DOM节点的好处是，页面的更新可以先全部反映在JS对象(虚拟DOM)上，操作内存中的JS对象的速度显然要更快，等更新完成后，再将最终的JS对象映射成真实的DOM，交由浏览器去绘制。\")]),t._v(\" \"),e(\"p\",[t._v(\"​\\tVirtual DOM 是以 JavaScript 对象为基础而\"),e(\"font\",{attrs:{color:\"red\",size:\"3\"}},[t._v(\"不依赖真实平台环境，所以使它具有了跨平台的能力\")]),t._v(\"，比如说浏览器平台、Weex、Node 等。\")],1),t._v(\" \"),e(\"p\",[e(\"strong\",[t._v(\"优点：\")])]),t._v(\" \"),e(\"div\",{staticClass:\"language- line-numbers-mode\"},[e(\"pre\",{pre:!0,attrs:{class:\"language-text\"}},[e(\"code\",[t._v(\"虚拟节点可以理解成节点描述对象，它描述了应该怎样去创建真实的DOM节点。\\n虚拟DOM优势：渲染引擎操作 DOM 慢，js运行效率高，于是将DOM对比操作放在JS层，提高效率\\n提升渲染性能 Virtual DOM的优势不在于单次的操作，而是在大量、频繁的数据更新下，能够对视图进行合理、高效的更新\\n\")])]),t._v(\" \"),e(\"div\",{staticClass:\"line-numbers-wrapper\"},[e(\"span\",{staticClass:\"line-number\"},[t._v(\"1\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[t._v(\"2\")]),e(\"br\"),e(\"span\",{staticClass:\"line-number\"},[t._v(\"3\")]),e(\"br\")])])])}),[],!1,null,null,null);s.default=n.exports}}]);","extractedComments":[]}