{"code":"(window.webpackJsonp=window.webpackJsonp||[]).push([[790],{1184:function(e,r,a){\"use strict\";a.r(r);var t=a(55),n=Object(t.a)({},(function(){var e=this,r=e.$createElement,a=e._self._c||r;return a(\"ContentSlotsDistributor\",{attrs:{\"slot-key\":e.$parent.slotKey}},[a(\"h1\",{attrs:{id:\"_1\"}},[a(\"a\",{staticClass:\"header-anchor\",attrs:{href:\"#_1\"}},[e._v(\"#\")]),e._v(\" 1\")]),e._v(\" \"),a(\"p\",[e._v(\"以下哪些正则表达式满足regexp.test('abc') === true？\")]),e._v(\" \"),a(\"p\",[a(\"img\",{attrs:{src:\"https://gitee.com/wddzhahaha/images/raw/master/img/image-20220318210820943.png\",alt:\"image-20220318210820943\"}})]),e._v(\" \"),a(\"p\",[e._v(\"补充一下B的先行断言：\")]),e._v(\" \"),a(\"ul\",[a(\"li\",[a(\"p\",[a(\"strong\",[e._v(\"(?=pattern) 正向先行断言\")]),e._v(\"\\n代表字符串中的一个位置，紧接该位置之后的字符序列能够匹配pattern。\\n例如对”a regular  expression”这个字符串，要想匹配regular中的re，但不能匹配expression中的re，可以用”re(?=gular)”，该表达式限定了re右边的位置，这个位置之后是gular，但并不消耗gular这些字符，将表达式改为”re(?=gular).”，将会匹配reg，元字符.匹配了g，括号这一砣匹配了e和g之间的位置。\")])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v('.匹配除“\\\\n”和\"\\\\r\"之外的任何单个字符。要匹配包括“\\\\n”和\"\\\\r\"在内的任何字符，请使用像“[\\\\s\\\\S]”的模式。')])]),e._v(\" \"),a(\"li\",[a(\"p\",[e._v(\"所以说在这里/...(?=.)/匹配的是：\\n前面任意三个字符，但是后面必须跟一个任意字符（除了\\\\n和\\\\r）。\\n但是题目给出来的字符串只有三个字符，该正则表达式至少要四个字符。\")]),e._v(\" \"),a(\"p\",[e._v(\"C.[ab]表示a或b {2}表示长度为2 [^defgh]表示非defgh的字符，所以可匹配的有,aac,bbc,abc,abcd等，注意这里匹配长度为3\")]),e._v(\" \"),a(\"p\",[e._v('D.\"*\"表示0或者多个字符，这里可匹配空，或者括号内任意字符')])])])])}),[],!1,null,null,null);r.default=n.exports}}]);","extractedComments":[]}